timed_lapply <- function(x, func, ...,
                         times_run = 1L,
                         ncores    = NA,
                         randomize_order   = TRUE,
                         return_times_only = FALSE) {

  if (is.na(ncores)) ncores <- detectCores() - 1

  if (randomize_order) x <- sample(x)

  if (return_times_only) {
    time_of_func <- function(x_i) {
      mb <- microbenchmark(
        func(x_i, ...),
        times = times_run,
        unit  = 's'
      )
      return(summary(mb)$mean)
    }
    result <- unlist(pbmclapply(
      x, time_of_func,
      mc.cores  = ncores
    ))
    if (randomize_order) {
      result <- result[order(x)]
    }
    return(result)

  } else {
    result <- matrix(NA, nrow = length(x), ncol = 3)
    colnames(result) <- c('x', 'y', 't')
    result[, 'x'] <- x

    y_and_t_for_x_i <- function(x_i) {
      mb <- microbenchmark(
        y_i <-  func(x_i, ...),
        unit  = 's'
      )
      t_i <- summary(mb)$mean
      # Return as vector instead of list for performance
      return(c(y_i, t_i))
    }
    y_and_t = pbmclapply(
      x, y_and_t_for_x_i,
      mc.cores  = ncores
    )
    # Get y and time values from each element in `y_and_t`.
    each_at_idx <- function(l, idx) {
      return(unlist(mclapply(
        l, function(l_i) {l_i[idx]}
      )))
    }
    result[, 'y'] <- each_at_idx(y_and_t, 1)
    result[, 't'] <- each_at_idx(y_and_t, 2)

    if (randomize_order) {
      result <- result[order(result[,'x']) ,]
    }
    return(result)
  }
}
