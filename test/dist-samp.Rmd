---
title: "dist-samp"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tictoc)
library(igraph)
knitr::opts_chunk$set(echo = TRUE)

knitr::opts_chunk$set(echo = TRUE)
# Set root directory of all chunks to current working directory.
# !!! NOTE: Change this to your directory if needed.
knitr::opts_knit$set(root.dir = getwd())

library(igraph)
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
# library(logger)
# library(parallel)
# library(readr)
library(rlang)
library(tictoc)
library(data.table)
library(netrb)
library(Matrix)
library(pbapply)
library(pbmcapply)
library(microbenchmark)

# Read example graphs from file.
graphs <- list(
  pg = read_graph('networks/power-grid.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  ir = read_graph('networks/internet-routers.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  cr = read_graph('networks/roads-ca.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  wa = read_graph('networks/eurosis-webatlas.graphml',
                  format   = 'graphml')
)
# Pre-calculate diameters of graphs, via igraph, Gephi, etc,
# since initializing a station_graph requires this,
# and it is computationally expensive
diams <- list(pg = 46,
              ir = 11,
              cr = 849,
              wa = 10)

r_source_dir  <- sprintf('%s/R', dirname(getwd()))
r_source_file_paths <- list.files(r_source_dir, full.names = TRUE)
```


```{r}
set.seed(1)
# g <- sample_gnm(5e2, 1)
# g <- sample_fitness_pl(1e3, 2e3, 2.5)
g <- graphs$pg
g <- largest_component(g)
d <- diameter(g)
md <- mean(netrb::distances(g), na.rm = TRUE)
md
# md2 <- igraph::mean_distance(g)
# md2
```


```{r}
md_err <- function(f1, f2, nr) {
  vc <- vcount(g)
  v1 <- sample(1:vc, round(f1*vc))
  v2 <- sample(1:vc, round(f2*vc))
  mda <- function(na) mean(
    netrb::distances(g = g,
                   v = v1,
                   to = v2,
                   diameter = d),
    na.rm = TRUE
  )
  # return(sapply(rep(NA, nr), mda))
  meanmda <- mean(unlist(mclapply(rep(NA, nr), mda, mc.cores = detectCores()-1)))
  return((abs(meanmda-md))/md)
}
n <- 30
nr <- 9
x1 <- seq(0.1, 1, length.out = n)
x2 <- seq(0.1, 1, length.out = n)
vs <- matrix(rep(x1,n), nrow=n,ncol=n)
ts <- matrix(rep(x1,n), nrow=n,ncol=n)
es <- matrix(rep(x1,n), nrow=n,ncol=n)
vs <- pbapply(vs, 1, function(x1_i) (x1_i*x2))
ts <- pbapply(ts, 1, function(x1_i) {
  timed_lapply(x2, md_err, f2 = x1_i, nr = nr, return_times_only = TRUE, times_run = 5)
})
es <- pbapply(es, 1, function(x1_i) {
   unlist(mclapply(x2, md_err, f2 = x1_i, nr = nr, mc.cores = detectCores() - 1))
})
vsp <- ggplot(melt(vs), aes(Var1, Var2)) +                           # Create heatmap with ggplot2
  geom_tile(aes(fill = value)) + 
  scale_fill_gradient(low = "white", high = "black")
vsp
tsp <- ggplot(melt(ts), aes(Var1, Var2)) +                           # Create heatmap with ggplot2
  geom_tile(aes(fill = value)) + 
  scale_fill_gradient(low = "white", high = "black")
tsp
```


```{r}
esp <- ggplot(melt(es), aes(Var1, Var2)) +                           # Create heatmap with ggplot2
  geom_tile(aes(fill = value)) + 
  scale_fill_gradient(low = "green", high = "red")
esp
```


```{r}
os <- es*ts
osp <- ggplot(melt(os), aes(Var1, Var2)) +                           # Create heatmap with ggplot2
  geom_tile(aes(fill = value)) +
  scale_fill_gradient(low = "green", high = "red")
osp
```

TODO style choices

indices rather than append
* runtime
* less error-prone

```{r}
ggp + 

vec1 <- c(1)
tic()
for (i in 2:1e4) vec1 <- c(vec1, i)
toc()
tic()
vec2 <- rep(NA, 1e4)
for (i in 1:1e4) vec2[i] <- i
toc()
```

