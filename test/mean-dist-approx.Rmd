---
title: "mean-dist-approx"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# Set root directory of all chunks to current working directory.
# !!! NOTE: Change this to your directory if needed.
knitr::opts_knit$set(root.dir = getwd())

library(igraph)
library(microbenchmark)
library(ggplot2)
library(reshape2)
library(dplyr)
library(tidyr)
# library(logger)
library(parallel)
# library(readr)
library(rlang)
library(tictoc)
library(data.table)
library(netrb)
library(Matrix)
library(pbapply)
library(pbmcapply)

# Read example graphs from file.
# Read example graphs from file.
graphs <- list(
  pg = read_graph('networks/power-grid.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  ir = read_graph('networks/internet-routers.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  cr = read_graph('networks/roads-ca.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  wa = read_graph('networks/eurosis-webatlas.graphml',
                  format   = 'graphml')
)
# Pre-calculate diameters of graphs, via igraph, Gephi, etc,
# since initializing a station_graph requires this,
# and it is computationally expensive
diams <- list(pg = 46,
              ir = 11,
              cr = 849,
              wa = 10)
```

```{r}
g <- sample_fitness_pl(40, 60, 2.5)
plot(g)
```



```{r}
set.seed(1)
g <- sample_gnm(10, 5)
# g <- graphs$pg
len <- 5
samp_vcs <- seq(from = 1, to = vcount(g), length.out = len)
mean(distances(g, v=sample(1:10, 5), to=sample(1:10, 5)))
```


```{r}
mean_distance_sample <- function(g, vcount_sample) {
  return(mean(distances(g,
    v  = sample(1:vcount(g), vcount_sample),
    to = sample(1:vcount(g), vcount_sample)
  )))
}
mean_distance_sample(g, 5)
```


```{r}
mean_distance_for_gnm_size <- function(n) {
  g <- sample_gnm(n, round(2*n))
  return(mean_distance(g))
}
tic()
set.seed(1)
t <- timed_lapply(samp_vcs, 
                  function(vc) mean_distance_sample(g, vc),
                  return_times_only = FALSE,
                  times_run = 1)
toc()
# plot(samp_vcs, t)
t
```
```{r}
y <- pbmclapply(samp_vcs, function(vc) {
  mean_distance_sample(g = g, vcount_sample = vc)
})
plot(samp_vcs, y)
```


```{r}
mean(c(3,Inf,1000))
g <- graphs$ir
n <- vcount(g)
rrn <- round(sqrt(sqrt(n)))
# g <- sample_gnm(n,2*n)
# TODO make applies use random seeds
foo <- function(na) {
  d <- igraph::distances(g,
               v =  sample(1:n,rrn),
               to = sample(1:n,rrn))
  d[d == Inf] <- NA
  d[d == 0] <- NA
  return(mean(d, na.rm = TRUE))
}
foo2 <- function(na) {
  md1r <- rep(NA, rrn)
  md1ap <- unlist(pbmclapply(md1r, foo,
                         mc.cores = as.integer(detectCores()-1)))
  return(mean(md1ap))
}
mdx <- foo2(NA)
mdx
```


## Runtime vs. Sampling Fractions
```{r}
g <- graphs$pg
hist(harmonic_centrality(g), breaks = 100)
hist(harmonic_centrality(g,
                         normalized = TRUE),
     breaks = 100)
```



```{r}
xyt <- timed_lapply(samp_vcs, mean_distance_sample, g = g)
plot_Ys_vs_X(xyt, 'x')
```


```{r}
foo <- pbmclapply(
  samp_vcs,
  function(vc) {
    res <- timed_func(function() {
      d <- igraph::distances(
        graph = g,
        v = sample(1:vcount(g), vc),
        to = sample(1:vcount(g), vc)
      )
      d[d == Inf] <- NA
      return(mean(d, na.rm = TRUE))
    },
    return_func_result = TRUE
    )
    print(res$result)
    mds[i] <- res$result
    times[i] <- res$time
    i <- i + 1
    return(res)
  },
  mc.cores = detectCores()
)
toc()
  # cl = cl

# stopCluster(cl)
```
