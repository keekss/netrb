---
title: "acc"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(ggplot2)
library(netrb)
library(pbapply)
library(pbmcapply)
library(microbenchmark)

# Read example graphs from file.
graphs <- list(
  pg = read_graph('networks/power-grid.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  ir = read_graph('networks/internet-routers.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  cr = read_graph('networks/roads-ca.txt',
                  format   = 'edgelist',
                  directed = FALSE),
  wa = read_graph('networks/eurosis-webatlas.graphml',
                  format   = 'graphml')
)
# Pre-calculate diameters of graphs, via igraph, Gephi, etc,
# since initializing a station_graph requires this,
# and it is computationally expensive
diams <- list(pg = 46,
              ir = 11,
              cr = 849,
              wa = 10)

r_source_dir  <- sprintf('%s/R', dirname(getwd()))
r_source_file_paths <- list.files(r_source_dir, full.names = TRUE)
```

```{r}
set.seed(1)
# g <- sample_gnm(5e2, 1)
# g <- sample_fitness_pl(1e3, 2e3, 2.5)
g <- graphs$pg
g <- largest_component(g)
d <- diameter(g)
md <- mean(netrb::distances(g), na.rm = TRUE)
md


n <- 20
# md sample repeats
nr <- 4
x1 <- seq(0.01, 0.05, length.out = n)
x2 <- seq(0.01, 0.05, length.out = n)
vs <- matrix(rep(x1,n), nrow=n,ncol=n)
ts <- matrix(rep(x1,n), nrow=n,ncol=n)
es <- matrix(rep(x1,n), nrow=n,ncol=n)
vs <- pbapply(vs, 1, function(x1_i) (x1_i*x2))
ts <- pbapply(ts, 1, function(x1_i) {
  timed_lapply(
    x2,
    function(x2_i) {
      mean_distance_approx(
        g = g,
        vs1 = x2_i,
        vs2 = x1_i,
        times_run = nr
      )
    },
    return_times_only = TRUE
  )
})
es <- pbapply(es, 1, function(x1_i) {
   unlist(mclapply(
    x2,
    function(x2_i) {
      mean_distance_approx_error(
        true_mean_distance = md,
        g   = g,
        vs1 = x2_i,
        vs2 = x1_i,
        times_run = nr
      )
    },
    mc.cores = detectCores() - 1)
  )
})
```

```{r}
ggh <- function(d, lc='white', hc='black') {
  ggplot(reshape2::melt(d), aes(Var1, Var2)) +                           # Create heatmap with ggplot2
  geom_tile(aes(fill = value)) + 
  scale_fill_gradient(low = lc, high = hc)
}
ggh(es, 'green', 'red')
# ggh(ts[1:18,1:18]*es[1:18,1:18], 'green', 'red')

```
```{r}
ggh(ts)
```

